#!/usr/bin/python3

import sys
import rospy
import cv2
import numpy as np
import tf2_geometry_msgs
import tf2_ros
from sensor_msgs.msg import Image
from geometry_msgs.msg import PointStamped, Vector3, Pose, Twist
from cv_bridge import CvBridge, CvBridgeError
from visualization_msgs.msg import Marker, MarkerArray
from std_msgs.msg import ColorRGBA
from message_filters import ApproximateTimeSynchronizer, Subscriber
import math
from tf.transformations import quaternion_from_euler
from std_msgs.msg import String


class The_Ring:


    def __init__(self):
            
        rospy.init_node('image_converter', anonymous=True)

        # An object we use for converting images between ROS format and OpenCV format
        self.bridge = CvBridge()

        # A help variable for holding the dimensions of the image
        self.dims = (0, 0, 0)

        # Marker array object used for visualizations
        self.marker_array = MarkerArray()
        self.green_array = MarkerArray()

        self.marker_num = 1

        self.arm = ""

        def doshit(data):
            rospy.sleep(2)
            self.arm = data.data.strip()

            # rostopic pub /arm_command std_msgs/String "data: 'retract'"


        self.arm_sub = rospy.Subscriber("/arm_command", String, doshit)

      
        # self.new_depth_sub = Subscriber("/arm_camera/depth/image_raw", Image)
        self.new_image_sub = Subscriber("/arm_camera/rgb/image_raw", Image)
        # self.ats = ApproximateTimeSynchronizer([self.new_depth_sub, self.new_image_sub], queue_size=5, slop=0.1)
        # self.ats.registerCallback(self.gotimage)

        # Subscribe to the image and/or depth topic
        self.image_sub = rospy.Subscriber("/arm_camera/rgb/image_raw", Image, self.image_callback)
        # self.depth_sub = rospy.Subscriber("/camera/depth/image_raw", Image, self.depth_callback)

        self.averages = []

        # Object we use for transforming between coordinate frames
        self.tf_buf = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buf)

        self.twist_pub = rospy.Publisher("/cmd_vel_mux/input/navi",Twist, queue_size=50)
        self.rotate = True
        self.center = True
        self.cheat = -1




    def image_callback(self,data):


        if self.arm != "extend":
            return

            
    
        # print('I got a new image!')

        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            print(e)

        # Set the dimensions of the image
        cv_image = cv_image[0:len(cv_image)-35,:]
        
        self.dims = cv_image.shape


        # if self.arm != "extend":
        #     cv2.imshow("Contour window",cv_image)
        #     cv2.waitKey(1)
        #     return
        
        # Tranform image to gayscale
        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)

        # Do histogram equlization
        img = cv2.equalizeHist(gray)

        # Binarize the image, there are different ways to do it
        #ret, thresh = cv2.threshold(img, 50, 255, 0)
        #ret, thresh = cv2.threshold(img, 70, 255, cv2.THRESH_BINARY)
        thresh = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, 25)

        # Extract contours
        contours, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_TC89_L1  )

        # Example how to draw the contours, only for visualization purposes
        # cv2.drawContours(cv_image, contours, -1, (0, 255, 0), 1)


        # Fit elipses to all extracted contours
        elps = []
        for cnt in contours:
            #     print cnt
            if cnt.shape[0] >= 30:
                ellipse = cv2.fitEllipse(cnt)
                elps.append(ellipse)


        # Find two elipses with same centers
        candidates = []
        for e in elps:
            # if e[1][0] / e[1][1] < 1.15 and e[1][0] / e[1][1] > 0.85 and ( e[1][0] < 500 and e[1][1] < 500 ): 
            if ( e[1][0] > 125 and e[1][1] > 125 ) and ( e[1][0] < 500 and e[1][1] < 500 ): 
                candidates.append(e)


        # for n in range(len(elps)):
        #     for m in range(n + 1, len(elps)):
        #         e1 = elps[n]
        #         e2 = elps[m]
        #         dist = np.sqrt(((e1[0][0] - e2[0][0]) ** 2 + (e1[0][1] - e2[0][1]) ** 2))
        #         # print(dist)
        #         rospy.loginfo(dist)
        #         if dist < 50:
        #             # print(e1[1][0] / e1[1][1])
        #             # if e1[1][0] / e1[1][1] < 1.1 and e1[1][0] / e1[1][1] > 0.9: 
        #             candidates.append(e1)
        #             candidates.append(e2)

        #             # if e2[1][0] / e2[1][1] < 1.1 and e2[1][0] / e2[1][1] > 0.9: 
        #                 # candidates.append(e2)



        # x = int(candidates[0][0][0][0])
        # y =int(candidates[0][0][0][1])
        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0


        # x = len(cv_image[0])/2
        # y = len(cv_image[0])/2
        

        if len(candidates) == 0:
            for e in elps:
                candidates.append(e)
            
        x = 0
        y = 0
        for e in candidates:
            
            # print(e)
            # x = int(e[0][0])
            # y = int(e[0][1])
            cv2.circle(cv_image, ( int(e[0][0]),int(e[0][1])), radius=1, color=(0, 122, 0), thickness=5)
            cv2.ellipse(cv_image, e, (122, 122, 0), 1)

            # elps[0,0] = list(elps[0,0])
            x += e[0][0]
            y += e[0][1]

        if len(candidates) == 0:
            return
    
        x /= len(candidates)
        y /= len(candidates)
        # print(np.unique(gray[:gray.shape[0]-50,:], return_counts= True))
        cv2.circle(cv_image, ( int(x),int(y)), radius=1, color=(255, 0, 255), thickness=5)



        #rotate until find perfect circle 


        # align rotation to center of parking spot
        if self.rotate:
            if x < len(cv_image[0])/2 - 10:
                twist.angular.z = 0.25
                twist.linear.x = 0.025
            elif x > len(cv_image[0])/2 + 10:
                twist.angular.z = -0.25
                twist.linear.x = 0.025
            else:
                self.rotate = False

        # move position to center of parking spot
        elif not self.rotate and self.center:
            g = gray[:gray.shape[0]-50,:]
            twist.linear.x = 0.07
            if not np.any(gray[int(gray.shape[0]/2):gray.shape[0]-115,:]==0):
                print("DONE")
                self.center = False


        # dont send twist msgs if rotations and position done
        if self.rotate or self.center:
            self.twist_pub.publish(twist)







        #https://www.programcreek.com/python/example/89409/cv2.fitEllipse

        if len(elps)>0:
            cv2.imshow("Image window",cv_image)
            cv2.waitKey(1)


def main():

    ring_finder = The_Ring()
    # rate = rospy.Rate(2)

    try:
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")

    cv2.destroyAllWindows()


if __name__ == '__main__':
    main()
